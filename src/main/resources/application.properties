spring.application.name=RealWorldBlog
# Prevents loading schema.sql and data.sql, relying on entity-based schema generation.
# Tells Hibernate to create the schema from entities at test startup and drop it afterward.
# spring.sql.init.mode=never
# spring.jpa.hibernate.ddl-auto=create-drop

# If you prefer to use schema.sql instead of entity-based schema generation, 
# ensure it's in src/test/resources or src/main/resources and enable SQL initialization:
# spring.jpa.hibernate.ddl-auto=none
# spring.sql.init.mode=always

spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:testdb
#spring.datasource.url=${DATABASE_URL}
#spring.datasource.username=${DATABASE_USER}
#spring.datasource.password=${DATABASE_PASSWORD}
spring.datasource.driverClassName=org.h2.Driver
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

#logging.level.org.springframework.test.context.cache=DEBUG

# This line modifies the default Spring Boot behavior and populates the data after the schema is generated by Hibernate.
# spring.jpa.defer-datasource-initialization=true
# If you create a custom schema.sql file, then the line above needs to be REMOVED and the line below needs to be ADDED
# spring.jpa.hibernate.ddl-auto=none => For Production will pick up schema.sql and data.sql
# spring.jpa.hibernate.ddl-auto=create-drop => for test case scenarios, will pick up schema.sql and omit data.sql

# To log JPA queries - https://www.baeldung.com/sql-logging-spring-boot
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

spring.sql.init.mode=never
spring.jpa.hibernate.ddl-auto=create-drop

server.port=${PORT:3000}
# enable @JsonRootName annotation
#spring.jackson.serialization.wrap-root-value=true
#spring.jackson.deserialization.unwrap-root-value=true
jwt.secret=yourVeryLongSecretKeyAtLeast32CharactersLong
jwt.expiration=86400

