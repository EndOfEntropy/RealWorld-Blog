Spring notes:
The rest controller and H2 automatically translate the field name and class name of the entity class (data class)
when running the CRUD controller tests.
	Some rules when the names are translated from a Java class to SQL queries:
		email => EMAIL
		userName => USER_NAME
		Some words are reserved like "user"
		
Use the @Table and @Column annotations to change the Java names into table/column names for the SQL queries
You can use records or build a regular Java class for your entity class

For some reason the column name in JSON has an added camel case "userName". 
Use the following code to check the column name after JSON serialization
	System.out.println(document.jsonString());

	
JPA vs JDBC
JPA is higher level as ORM while JDBC is more detailed in its approach and uses SQL statements

JPA handles the table relationships and queries by itself, for example @Entity is only used in JPA.
Comprehensive guide to annotations in Spring Boot JPA
https://medium.com/@yadavsunil9699/a-comprehensive-guide-to-annotations-in-spring-boot-jpa-950a05b5eb1b
@OneToOne, @OneToMany, @ManyToOne, and @ManyToMany
https://medium.com/@zgokceaynaci/spring-jpa-annotations-863574d13121
https://www.baeldung.com/jpa-many-to-many

You can override this behavior creating sql schema and data files thanks to Spring Boot auto-configuration
	shema.sql is saved under src/main/resources
	data.sql is saved under src/main/resources or src/test/resources
	
However, the main folder takes precedence over the test location. In order to have 2 different files for test and main,
manual configuration is required by creating 2 separate configurations by using application.properties and a configuration class 
	
Testing
In the Post CRUD test case, the id should be null, otherwise the rest controller fetches the provided id and will results in an error


Spring Boot Data JPA alone and access to the H2 console
The H2 console is implemented as a Jakarta Servlet. You'll always need a servlet container like Tomcat or Jetty to run it.
A Spring Boot application that depends only on Spring Data JPA does not have an embedded servlet container. Thus, it cannot host the H2 console.
You need to add Spring Web if you want the H2 console. Spring Boot will then auto-configure Tomcat as servlet container.

@DataJpaTest: By default it will configure an in-memory embedded database, scan for @Entity classes and configure Spring Data JPA repositories. 
//Regular @Component beans will not be loaded into the ApplicationContext.
//Data JPA tests are transactional and rollback at the end of each test by default

Initial data loading
This line modifies the default Spring Boot behavior and populates the data after the schema is generated by Hibernate.
spring.jpa.defer-datasource-initialization=true
If you create a custom schema.sql file, then the line above needs to be REMOVED and the line below needs to be ADDED to the application.property file.
spring.jpa.hibernate.ddl-auto=none

SQL primary key generation
BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY = the value has a default auto incrementation, but you can insert your own.
However, the auto incrementation starts at 1, 2, 3, 4 etc

Summary: MockMvc vs. WebTestClient vs. TestRestTemplate
All three tools help us invoke and test our Spring Boot application's endpoint.
https://rieckpil.de/spring-boot-testing-mockmvc-vs-webtestclient-vs-testresttemplate/

Endpoints
RealWorld app sets the following endpoints: POST = /api/users and GET/PUT/DELETE = /api/user
This means that enpoints are not a location where the data is saved like a hard drive,
but rather a URL address to receive a request type. The data is saved in-memory by H2.

Hibernate
@OneToMany: a One to Many annotations is needed to create a relation between two entities (TABLE).
For example, a store has many branches, and they both are an entity, that means they both have a table inside our database.
After running the code, Hibernate will create two tables inside the database, the first one called store and the second called branch.
A repository needs to be created for both entities to insert and get the data from the database.

@ElementCollection: this a collection of simple types (Strings, etc.) or a collection of @Embeddable elements, not a collection of entities.
Elements can’t have their own lifecycle. They are owned by the containing entities and are modified/deleted etc when the entity is modified/deleted etc

https://medium.com/nerd-for-tech/elementcollection-vs-onetomany-in-hibernate-7fb7d2ac00ea
https://medium.com/codex/element-collection-vs-one-to-many-in-jpa-andhibernate-e4ae83642d99

@Embedded and @Embeddable (User and Profile)
This allows the Profile's properties (username and bio) to be directly mapped to the columns of the User table, 
even though they are encapsulated within a separate class in the domain model.
This modularizes the code and separates concerns within the domain model without changing the underlying database schema.
https://medium.com/jpa-java-persistence-api-guide/mastering-embedded-entities-in-hibernate-and-spring-data-jpa-a-comprehensive-guide-88a6cab58675

Layer,Test Type,Tool,What to Test
1. Controller + Security,Unit Test,@WebMvcTest + @Import,Public API behavior
2. Service Logic,Unit Test,@ExtendWith(MockitoExtension.class),Business rules
3. Full Flow,Integration Test,@SpringBootTest + TestRestTemplate,"DB, JWT, filters"

TODOs list:
 - ArticleControllerUnitTest and CommentControllerUnitTest tests fail
 - Add a separate Tag entity and @ManyToMany relationship between Article and Tag - Done
 - Add request/response DTOs to all endpoints/APIs (User, Article, Comment and Tag) - Done
 - Integration tests? Test edge cases, when methods fail?
 - Use H2/Postman to check that the database is accurate - https://realworld-docs.netlify.app/specifications/backend/postman/ - Done
 - Add authentication and authorization - Done, code flow not fully understood
 - Add aspect oriented programming (logs)
Next prompt
 If you want, I can suggest a few ways to document and “package” this project so it really shines on your portfolio or resume. 
 It’ll make all that effort even more visible.
 
H2 console
localhost:8080/h2-console
 